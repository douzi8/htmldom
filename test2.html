
<script type="text/javascript">
/**
 * 空元素标签
 * https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0
 */

// @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
const VOID_ELEMENTS = [
  'area', 
  'base', 
  'br', 
  'col', 
  'embed', 
  'hr', 
  'img', 
  'input', 
  'keygen', 
  'link',
  'menuitem', 
  'meta', 
  'param', 
  'source', 
  'track', 
  'wbr'
]

const OPTIONAL_TAGS = {
  head: ['body'],
  /**
   * </li>可以在以下两种情况下缺省
   * 1. <li>紧挨着另一个<li>
   * 2. 父亲元素没有更多的内容
   *
   * @example
   * <ul>
   *  <li> 1
   *  <li> 2
   * </ul>
   */
  li: ['li'],
  dt: ['dt', 'dd'],
  dd: ['dd', 'dt'],
  p: ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p',' pre', 'section', 'table', 'ul'],
  option: ['option'],
  caption: ['caption', 'thead', 'tbody'],
  colgroup: ['tbody', 'tr', 'tfoot'],
  col: ['col', 'tbody', 'tr'],
  thead: ['tbody', 'tfoot'],
  tbody: ['tbody', 'tfoot'],
  tfoot: ['tbody'],
  tr: ['tr', 'tbody'],
  td: ['td', 'th', 'tr', 'tbody'],
  th: ['td', 'th', 'tr', 'tbody']
}

const OPTIONAL_END_TAGS = ['p']

// Raw text elements
// script, style, textarea


/**
 * 自闭合标签
 * 
 */

/**
 *  {
 *     type: 'tag',
 *     name: 'div',
 *     isSelfClosing: false,
 *     children: 
 *     parent
 *     
 *  }
 */


  const REG = {
    // <style, <script
    RAW_TAG: /^<(script|style|textarea)/,
    STYLE_RAW: /([\s\S]*?)<\/style\s*>/,
    SCRIPT_RAW: /([\s\S]*?)<\/script\s*>/,
    TEXTARE_RAW: /([\s\S]*?)<\/textarea\s*>/,
    // <div
    OPEN_TAG: /^<([\w-]+)/,
    // >
    OPEN_TAG_CLOSE: /^(?:'[^']*'|"[^"]*"|[^>])*>/,
    // </div>
    CLOSE_TAG: /^<\/([\w-]+)\s*>/,
    // <!-- -->
    COMMENT: /^<!--([\s\S]*)-->/,
    TEXT: /^[^<]+/,
    WHITESPACE: /^\s+/
  }

  function getRawEndTag (name) {
    if (name === 'style') {
      return REG.STYLE_RAW
    }

    if (name === 'script') {
      return REG.SCRIPT_RAW
    }


    if (name === 'textarea') {
      return REG.TEXTARE_RAW
    }
  }

  function isVoidElement(name) {
    return VOID_ELEMENTS.includes(name)
  }


  class Scanner {
    /**
     * @param {string} str Html code
     */
    constructor (str) {
      this.str = str
      this.doms = []
      this.scan()
    }

    scan () {
      while (this.str) {
        this.trimLeft()

        if (this.rawTag()) {
          continue
        }

        if (this.openTag()) {
          continue
        }

        if (this.closeTag()) {
          continue
        }

        if (this.comment()) {
          continue
        }

        this.text()
      }
    }
    /**
     * match content step by step
     * @example
     * this.match(/^<([\w-]+)/)
     */
    match (reg) {
      let match = this.str.match(reg)

      if (!match) {
        return false
      }

      this.str = this.str.slice(match[0].length)

      return match
    }

    trimLeft () {
      let match = this.match(REG.WHITESPACE)

      if (!match) return false

      this.doms.push({
        type: 'text',
        value: match[0]
      })

      return true
    }

    /**
     * match like: <script>, <style>, <textarea>
     */
    rawTag () {
      let match = this.match(REG.RAW_TAG)

      if (!match) return false


      let attributes = this.match(REG.OPEN_TAG_CLOSE)

      if (!attributes) return

      let name =  match[1]  
      let endTag = getRawEndTag(name)

      let content = this.match(endTag)

      if (content) {
        content = content[1]
      }  else {
        content = this.str
        this.str = ''
      }

      let item = {
        type: 'rawTag',
        name,
        attributes: attributes[0].slice(0, -1),
        content
      }

      this.doms.push(item)

      return true    
    }

    /**
     * match like: <div>,  <input>, ...
     */
    openTag () {
      let match = this.match(REG.OPEN_TAG)

      if (!match) return false

      let attributes = this.match(REG.OPEN_TAG_CLOSE)

      if (!attributes) return false

      attributes = attributes[0].slice(0, -1).trim()

      let isSelfClosing = attributes.endsWith('/')

      if (isSelfClosing) {
        attributes = attributes.slice(0, -1)
      }

      let name = match[1]
      let type

      if (isSelfClosing) {
        type = 'selfClosingTag'
      } else {
        type = isVoidElement(name) ? 'voidTag' : 'openTag'
      }

      let item = {
        type,
        name,
        attributes
      }

      this.doms.push(item) 

      return true
    }

    /**
     * match like: </div>, </title>
     */
    closeTag () {
      let match = this.match(REG.CLOSE_TAG)

      if (!match) return false

      // if this is avoid tag, return statement 
      let name =  match[1]

      if (isVoidElement(name)) return false

      let item = {
        type: 'closeTag',
        name
      }  

      this.doms.push(item)

      return true
    }

    comment () {
      let match = this.match(REG.COMMENT)

      if (!match) return false

      let item = {
        type: 'comment',
        value: match[1]
      }  

      this.doms.push(item)

      return true
    }
    /**
     * match text node
     */
    text () {
      let match = this.match(REG.TEXT)
      let value

      if (match) {
        value = match[0]
      } else if (this.str[0] === '<') {
        value = '<'
        this.str = this.str.slice(1)
      } else {
        return false
      }

      let doms = this.doms

      let last = doms[doms.length - 1]

      if (last && last.type === 'text') {
        last.value += value
        return
      } 

       doms.push({
        type: 'text',
        value
      })
    }
  }

  class Parser {
    constructor (doms) {
      console.log([...doms])

      this.doms = doms
      this.nodes = this.traverse(null)
    }

    traverse (parent) {
      let doms = this.doms
      let nodes = []

      while (doms.length) {
        let item = this.shift()
        let node

        switch (item.type) {
          case 'openTag':
            node = this.matchOpenTag(parent, item)
            break
          case 'closeTag':
            if (this.matchCloseTag(parent, item)) {
              return nodes
            }

            break
          case 'rawTag':
          case 'voidTag':
          case 'selfClosingTag':
            node = {
              ...item,
              type: 'tag',
              tagType: item.type,
              children: []
            }
            break
          case 'text':
          case 'comment':
            node = item
            break
        }

        if (node) {
          node.parent = parent

          this.parseAttributes(node)

          nodes.push(node)
        }
      }

      return nodes
    }

    matchOpenTag (prev, node) {
      if (prev) {
        let optional = OPTIONAL_TAGS[prev.name]

        // optional tags
        if (optional && optional.includes(node.name)) {

          this.doms.unshift({
            type: 'closeTag',
            name:  prev.name
          }, node)

          return null         
        }
      }

      node.type = 'tag'
      node.children =  this.traverse(node)

      return node
    }

    matchCloseTag (prev, node) {
      let nodeName = node.name

      if (prev && prev.name === nodeName) {
        return true
      }

      if (nodeName === 'p') {
        this.doms.unshift({
          type: 'openTag',
          attributes:'',
          name: nodeName
        }, node)
      }

      return false
    }
    /**
     * Convert attributes string to object
     * @example
     * Empty attribute syntax: <input disabled> (https://html.spec.whatwg.org/multipage/syntax.html#attributes-2)
     * Unquoted attribute value: <input value=yes>
     * Single-quoted attribute value: <input type='checkbox'>
     * Double-quoted attribute value: <input name="be evil">
     */
    parseAttributes (node) {
      if (node.type !== 'tag') return

      let attributes = node.attributes.trim()
      let result = {}
      let reg = /([^=\s]+)(?:\s*=\s*(?:'([^']*)'|"([^"]*)"|([^\s]*)))?/g
      let match = reg.exec(attributes)

      while (match) {
        let key = match[1]
        let value = match[2] || match[3] || match[4] || ''

        result[key] = value

        match = reg.exec(attributes)
      }

      node.attributes = result
    }

    shift () {
      return this.doms.shift()
    }
  }

  let util = {
    isUndefined (obj) {
      return obj === void 0
    }
  }

  let GET_HTML = Symbol('getHtml')
  let GET_NODES = Symbol('getNodes')


  function getAttributesCode (attributes) {
    let result = ''
    
    for (let key in attributes) {
      let value = attributes[key]

      if (value) {
        result += ` ${key}=${value}`
      } else {
        result += ` ${key}`
      }
    }

    return result
  }

  /**
   * Get a node's html code
   * 
   * @example
   * {
   *   type: 'tag',
   *   children: [{ type: 'text', value: 1 }],
   *   name: 'div' 
   * }
   * <div>1</div>
   */
  function getOuterHTML ({
    name, 
    type, 
    tagType, 
    children,
    attributes,
    value
  }) {
    let code = []

    switch (type) {
      case 'tag':
        code.push(`<${name}${getAttributesCode(attributes)}`)

        if (tagType === 'selfClosingTag') {
         // <img src="" />
          code.push('/>')
        } else if (tagType === 'voidTag') {
          // <br>
          code.push('>')
        } else {
          code.push('>')
          
          for (let item of children) {
            code.push(getOuterHTML(item))
          }

          code.push(`</${name}>`)
        }

        break
      case 'text':
        code.push(value)
        break
    }

    return code.join('')
  }
 

  class QuerySelector {
    constructor (selector, rootNode) {
      this.rootNode = rootNode
    }

    find (selector) {
      let docCtx = this[GET_NODES]()

      return new QuerySelector(selector, docCtx)
    }

    html (content) {
      if (util.isUndefined(content)) {
        return QuerySelector.getHtml(this.rootNode)
      }
    }

    static getHtml (node) {
      let html = '';
      let children = node.children;

      for (let i = 0; i < children.length; i++) {
        html += getOuterHTML(children[i])
      }

      console.log(node)
      console.log(html)

      return html

      /*breadthFirstSearch(node, function (item) {
        let type = item.type

        if (type === 'root') return

        if (type === 'tag') {
          code.push(`<${item.name}>`)
          return
        }

        code.push(item.value)
      })
*/
      //console.log(node)
    }

    [GET_NODES] () {
      let nodes = []


      for (let i = 0; i < this.length; i++) {
        nodes.push(this[i])
      }

      return nodes
    }
  }

  /**
   * DFS
   */
  function depthFirstSearch (node, callback) {
    let stack = [node]

    while (stack.length) {
      let current = stack.shift()

      callback(current)

      if (current.children) {
        stack = current.children.concat(stack)
      }
    }
  }

  /**
   * BFS
   */
  function breadthFirstSearch (node, callback) {
    let stack = [node]

    while (stack.length) {
      let current = stack.shift()

      callback(current)

      if (current.children) {
        stack = stack.concat(current.children)
      }
    }
  }

  function getRootHtml (nodes) {
    let code = []

    for (let item of nodes) {
      depthFirstSearch(item, function (node) {
        code.push(`<${node.name}`)
      })
    }

    
  }


  function createDomTree (str) {
    let scan = new Scanner(str.trimRight())
    let parser = new Parser(scan.doms)
    let rootNode = {
      type: 'root',
      children: parser.nodes
    }

    let $ = function (selector) {
      return new QuerySelector(selector, rootNode)
    }

    $.html = function () {
      //return getRootHtml(parser.nodes)
    }

    return $
  }

   let htmlCode = `<head><title>Hello</title>
 <meta charset = "UTF-8">
</head>
<input id="0">
<image src="" />
1<p>2</p>3</p>`

  let $ = createDomTree(htmlCode)

  $('body').html()

  //console.log($.html())  

 // console.log()

  //console.log(htmlCode)

</script>